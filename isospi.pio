;
; Copyright (c) 2025 Collin Kidder
;
; MIT License (Do as thou wilt be the whole of the law)
;
; Two state machines that are meant to run on the same PIO Block
; Implements the tesla specific isoSPI interface used on the batteries
; for Model 3/Y and I believe newer Model S as well

.pio_version 0 // only requires PIO version 0
.program isospi_tx
.clock_div 1.5625 ;125 / 1.5625 = 80Mhz

//order of pins from 6,7,8,9 is NN NP PN PP
//The ?P pins idle high while ?N pins idle low
.define BITS_NEUTRAL 0b0101
.define BITS_POSITIVE 0b0110
.define BITS_NEGATIVE 0b1001

SET PINS BITS_NEUTRAL ;default to line not being driven
.wrap_target
OUT X 1 ;shift one bit from OSR, stalls if no bits available so program will normally be stuck here
SET PINS BITS_POSITIVE [25] ;got a bit so start CS assert - 26 cycles 12.5 * 26 = 325us
SET PINS BITS_NEGATIVE [25] ;negative pulse to finish CS assert
SET PINS BITS_NEUTRAL  [6]; ;give 6 clocks (6 * 12.5 = 75us) between CS and starting to send data bits
NEXT_BIT:
JMP !X ZERO_PULSE ;check the bit we grabbed. Is it not set? Then jump, otherwise keep going below (clock #4 of extra delay when looping)
SET PINS BITS_POSITIVE [9] ;1 bit so send positive pulse first for 10 clocks (10 * 12.5 = 125us)
SET PINS BITS_NEGATIVE [8] ;send negative pulse for 9 clocks
JMP AFTER ;spend a clock cycle jumping to AFTER (gives the 10th clock we need for negative signal)
ZERO_PULSE:
SET PINS BITS_NEGATIVE [9] ;0 bit so send negative pulse then positive pulse
SET PINS BITS_POSITIVE [9] ;no jump after this so need that extra clock
AFTER:
SET PINS BITS_NEUTRAL [31] ;set lines back to neutral for 32 clocks
SET PINS BITS_NEUTRAL [23] ;set them again to neutral for 24 more (60 clocks = 750us, but there are 4 clocks to go before we get to next bit so allow for them)
JMP !OSRE GET_BIT ;if we aren't out of data then go to GET_BIT to grab another bit (here is one of those clocks)
SET PINS BITS_NEGATIVE [25] ;then do CS deassert (neg long then pos long)
SET PINS BITS_POSITIVE [25]
SET PINS BITS_NEUTRAL
.wrap //go back to beginning of main loop
GET_BIT:
OUT X 1 ;grab one more bit (which we know to be there because we checked, no delay here) (clock #2 of extra delay)
JMP NEXT_BIT ;Jump back to decision code (Clock #3 of extra delay)



; most complicated program I have ever written!
.program isospi_rx
.pio_version 0 // only requires PIO version 0
.clock_div 1.5625 ;125 / 1.5625 = 80Mhz

.wrap_target
IN PINS 2 ;grab state of both input pins, place them in ISR, automatic transfer to FIFO will happen at 32bit boundaries
.wrap


% c-sdk {
#include "hardware/gpio.h"
static inline void pio_isospi_init(PIO pio, uint sm, uint offset, uint tx_base, uint rx_base)
{
    pio_sm_config c_tx = isospi_tx_program_get_default_config(offset);
    sm_config_set_out_pins(&c_tx, tx_base, 4);
    sm_config_set_set_pins(&c_tx, tx_base, 4);

    //pio_sm_config c_rx = isospi_rx_program_get_default_config(0);
    //sm_config_set_in_pins(&c_rx, rx_base);
    
    //(shift to left, auto push/pull, threshold=32)
    sm_config_set_out_shift(&c_tx, false, true, 32);
    //sm_config_set_in_shift(&c_rx, false, true, 32);

    
    //pio_sm_set_pins_with_mask(pio, sm, 0, (1u << pin_sck) | (1u << pin_mosi));
    pio_sm_set_pindirs_with_mask(pio, sm, (0xFu << tx_base), (0xFu << tx_base) | (3u << rx_base) );
    pio_gpio_init(pio, tx_base);
    pio_gpio_init(pio, tx_base + 1);
    pio_gpio_init(pio, tx_base + 2);
    pio_gpio_init(pio, tx_base + 3);
    
    pio_sm_init(pio, sm, offset, &c_tx);
    pio_sm_set_enabled(pio, sm, true);

    //pio_sm_init(pio, 1, 18, &c_rx);

}
%}
